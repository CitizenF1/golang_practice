package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"strconv"
	"sync"
	"time"
)

type Storage struct {
	m    *sync.Mutex
	root string
}

func CreateStorage() *Storage {
	root := "./storage"
	os.Mkdir(root, 0755)
	return &Storage{
		m:    &sync.Mutex{},
		root: root,
	}
}

// range specification, note that min <= max
type IntRange struct {
	min, max int
}

// get next random value within the interval including min and max
func (ir *IntRange) NextRandom(r *rand.Rand) int {
	return r.Intn(ir.max-ir.min+1) + ir.min
}

func removeDuplicateStr(strSlice []string) []string {
	allKeys := make(map[string]bool)
	list := []string{}
	for _, item := range strSlice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			list = append(list, item)
		}
	}
	return list
}

func RangeInt(n int) []string {
	var res []string
	// rr := map[int]string{}
	var done []string
	theBoys := []string{
		"rakhotep",
		"Randomllll",
		"Magauiya00",
		"drinksu",
		"Tima_b",
		"ganikazbek",
		"MarkusDosmagambetov",
		"Sakenever",
		"askarbai1",
		"azimkhankuat",
		"Baglan2",
		"rayodelsol01",
		"AzamatBK4",
		"ykabylbekov",
		"adilbekov23",
		"nurik_yes",
		"yerlawkaa",
		"CTZNF1",
		"OPTIMUS_GANK",
		"Bakbergen_M",
		"Deus_loVult7",
		"jc1an",
		"runreyvo",
	}

	var r int
	for r = 0; r <= n-1; r++ {
		// arr[r] = rand.Intn(max) + min
		done = append(done, theBoys[rand.Intn(len(theBoys))])
	}
	res = removeDuplicateStr(done)

	// fmt.Println(CheckDuplicate(done))
	return res
}

// rand.Seed(time.Now().UnixNano())
// min := 5
// max := 20
// fmt.Println(rand.Intn(max-min) + min)

func main() {
	rand.Seed(time.Now().UnixNano())
	// for _, v := range RangeInt(4) {
	// 	fmt.Println(v)
	// }
	// fmt.Println(RangeInt(5))
	fmt.Println(RangeInt(5))

	// a := 10.0
	// b := 35.0
	// r := b / a
	// fmt.Println(math.Ceil(r))

	//////////////////////////////////
	// r := rand.New(rand.NewSource(4))
	// ir := IntRange{1, 20}
	// min := 5
	// max := 20
	// for i := 0; i < 4; i++ {
	// 	fmt.Println(rand.Intn(max-min) + min)
	// }
	////////////////////////////////////
	// nums := [6]int{0, 2, 1, 5, 3, 4}
	// fmt.Println(buildArray(nums[:]))
	///==========BYTE request
	// data, err := os.ReadFile("./image.png")
	// if err != nil {
	// 	fmt.Println(err)
	// }
	// // fmt.Println(data)

	// req, err := http.NewRequest("POST", "http://localhost:7360", bytes.NewBuffer(data))
	// if err != nil {
	// 	fmt.Println(err)
	// }
	// client := &http.Client{}
	// resp, err := client.Do(req)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return
	// }
	// defer resp.Body.Close()
	// io.Copy(os.Stdout, resp.Body)
	//====================
	// do not modify below here, readline is our function
	// that properly reads in the input for you

	//lettercount
	// fmt.Println(LetterCount("Hello apple pie"))
	// fmt.Printf("%v\n", StringMerge("abc1*kyoo"))
	// fmt.Println(StringMerge("abc1*kyoo"))

}

func BinarySearch(list []int, item int) int {
	low := 0
	high := len(list) - 1

	for low <= high {
		mid := (low + high) / 2
		// fmt.Println(mid, "mid")
		guess := list[mid]

		if guess == item {
			return mid
		}
		if guess > item {
			high = mid - 1
		} else {
			low = mid + 1
		}
	}
	return 0
}

// func main() {

// client, err := rpc.DialHTTP("tcp", "192.168.0.76"+":7350")
// if err != nil {
// 	log.Fatal("dialing:", err)
// }
// var reply int
// err = client.Call("http_handler_path", "{some : data}", &reply)
// if err != nil {
// 	log.Fatal("arith error:", err)
// }
// fmt.Print("Arith: %d*%d=%d", reply)

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
// body := strings.NewReader(`"{"some": "data"}"`)
// req, err := http.NewRequest("POST", "http://192.168.0.76:7350/v2/rpc/http_handler_path?http_key=defaulthttpkey", body)
// if err != nil {
// 	// handle err
// 	fmt.Println(err, "req")
// }
// req.Header.Set("Content-Type", "application/json")
// req.Header.Set("Accept", "application/json")

// resp, err := http.DefaultClient.Do(req)
// if err != nil {
// 	// handle err
// 	fmt.Println(err, "resp")
// }
// defer resp.Body.Close()

// socket, err := socket.Dial(context.Background(), "tcp", "localhost:8081")
// if err != nil {
// 	fmt.Println(err)
// }
// fmt.Println(socket.LocalAddr())
// client := &http.Client{}
// // Perform the request	// conn, err := net.Dial("tcp", "192.168.0.159:7351")
// if err != nil {
// 	fmt.Println(err)
// 	return
// }

// defer conn.Close()
// io.Copy(os.Stdout, conn)
// fmt.Println("\nDone")0", "text/plain", bytes.NewBufferString("Hello Go!"))
// if err != nil {
// 	log.Fatalf("Failed get: %s", err)
// }
// defer resp.Body.Close()
//==============================================
// c := evtwebsocket.Conn{
// 	OnConnected: func(w *websocket.Conn) {
// 		fmt.Println("Connected")
// 	},
// 	OnMessage: func(msg []byte) {
// 		fmt.Printf("Received message: %s\n", msg)
// 	},
// 	OnError: func(err error) {
// 		fmt.Printf("** ERROR **\n%s\n", err.Error())
// 	},
// }
// // Connect
// c.Dial("http://localhost:7350")
// c.Send([]byte("TEST"), nil)
//===================================================

// }

//========================================================================
// func main() {
// RemoveFolder("test5")
// fmt.Println(os.Getwd())

// for i := 0; i < 10; i++ {
// 	for k := 0; k < 9-i; k++ {
// 		fmt.Print("-")
// 	}
// 	for starts := 0; starts < 2*i+1; starts++ {
// 		fmt.Print("*")
// 	}
// 	fmt.Println("-")
// }

// CreateStorage().MoveFile("test4", ".storage/", "test3")
// RemoveFile("storage/test1", "file.txt")
// CreateFile(storage, "fl.txt")
// fmt.Println(listFolder(("./storage/")))

// err := filepath.Walk("/file.txt",
// 	func(path string, info os.FileInfo, err error) error {
// 		if err != nil {
// 			return err
// 		}
// 		fmt.Println(path)
// 		return err
// 	})
// if err != nil {
// 	log.Println(err)
// }

// f, err := os.Open("./storage")
// if err != nil {
// 	fmt.Println(err)
// 	return
// }
// files, err := f.Readdir(0)
// if err != nil {
// 	fmt.Println(err)
// 	return
// }

// for _, v := range files {
// 	fmt.Println(v.Name(), v.IsDir())
// }
// dir, err := os.Getwd()
// if err != nil {
// 	log.Fatal(err)
// }
// fmt.Println(dir)
// fmt.Println(FilePathWalkDir("./"))
// fmt.Println(OSReadDir("./storage/test1/file.txt"))

// }

func FilePathWalkDir(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func OSReadDir(root string) ([]string, error) {
	var files []string
	f, err := os.Open(root)
	if err != nil {
		return files, err
	}
	fileInfo, err := f.Readdir(-1)
	f.Close()
	if err != nil {
		return files, err
	}

	for _, file := range fileInfo {
		files = append(files, file.Name())
	}
	return files, nil
}

func listFolder(path string) (string, error) {
	var files string
	fileInfo, err := ioutil.ReadDir(path)
	if err != nil {
		log.Fatal(err)
	}

	for i := range fileInfo {
		files += fileInfo[i].Name() + " " + strconv.FormatBool(fileInfo[i].IsDir()) + "\n"
	}
	return files, err
}

func CreateFile(location string, fileName string) error {
	file, err := os.Create(location + "/" + fileName)
	if err != nil {
		log.Fatal(err)
	}
	file.Close()

	return nil
}

func (this *Storage) MoveFile(fileName string, oldPath string, newPath string) error {
	err := os.Rename(filepath.Join(oldPath, fileName), filepath.Join(newPath, fileName))
	if err != nil {
		log.Fatal(err)
	}
	return nil
}

// func twoSum(nums []int, target int) []int {
// 	mapNums := map[int]int{}
// 	for i := range nums {
// 		dif := target - nums[i]
// 		val, isExist := mapNums[dif]
// 		if isExist == true {
// 			return []int{val, i}
// 		} else {
// 			mapNums[nums[i]] = 1
// 		}
// 	}
// 	return nil
// }

// type ListNode struct {
// 	Val  int
// 	Next *ListNode
// }

// func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {

// }

//LEGASY CODE

// url := "https://www.google.com/"
// fmt.Printf("HTML code of %s ...\n", url)
// resp, err := http.Get(url)
// // handle the error if there is one
// if err != nil {
// 	panic(err)
// }
// // do this now so it won't be forgotten
// defer resp.Body.Close()
// // reads html as a slice of bytes
// html, err := ioutil.ReadAll(resp.Body)
// if err != nil {
// 	panic(err)
// }
// // show the HTML code as a string %s
// fmt.Printf("%s\n", html)

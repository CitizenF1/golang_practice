package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"sync"
)

type Storage struct {
	m    *sync.Mutex
	root string
}

func CreateStorage() *Storage {
	root := "./storage"
	os.Mkdir(root, 0755)
	return &Storage{
		m:    &sync.Mutex{},
		root: root,
	}
}

func main() {
	nums1 := [4]int{1, 2, 3, 4}
	nums := [10]int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}
	fmt.Println(containsDuplicate(nums[:]))
	fmt.Println(containsDuplicate(nums1[:]))

	///==========BYTE request
	// data, err := os.ReadFile("./image.png")
	// if err != nil {
	// 	fmt.Println(err)
	// }
	// // fmt.Println(data)

	// req, err := http.NewRequest("POST", "http://localhost:7360", bytes.NewBuffer(data))
	// if err != nil {
	// 	fmt.Println(err)
	// }
	// client := &http.Client{}
	// resp, err := client.Do(req)
	// if err != nil {
	// 	fmt.Println(err)
	// 	return
	// }
	// defer resp.Body.Close()
	// io.Copy(os.Stdout, resp.Body)
	//====================
	// do not modify below here, readline is our function
	// that properly reads in the input for you

	//lettercount
	// fmt.Println(LetterCount("Hello apple pie"))
	// fmt.Printf("%v\n", StringMerge("abc1*kyoo"))
	// fmt.Println(StringMerge("abc1*kyoo"))

}

func BinarySearch(list []int, item int) int {
	low := 0
	high := len(list) - 1

	for low <= high {
		mid := (low + high) / 2
		// fmt.Println(mid, "mid")
		guess := list[mid]

		if guess == item {
			return mid
		}
		if guess > item {
			high = mid - 1
		} else {
			low = mid + 1
		}
	}
	return 0
}

// func main() {

// client, err := rpc.DialHTTP("tcp", "192.168.0.76"+":7350")
// if err != nil {
// 	log.Fatal("dialing:", err)
// }
// var reply int
// err = client.Call("http_handler_path", "{some : data}", &reply)
// if err != nil {
// 	log.Fatal("arith error:", err)
// }
// fmt.Print("Arith: %d*%d=%d", reply)

// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
// body := strings.NewReader(`"{"some": "data"}"`)
// req, err := http.NewRequest("POST", "http://192.168.0.76:7350/v2/rpc/http_handler_path?http_key=defaulthttpkey", body)
// if err != nil {
// 	// handle err
// 	fmt.Println(err, "req")
// }
// req.Header.Set("Content-Type", "application/json")
// req.Header.Set("Accept", "application/json")

// resp, err := http.DefaultClient.Do(req)
// if err != nil {
// 	// handle err
// 	fmt.Println(err, "resp")
// }
// defer resp.Body.Close()

// socket, err := socket.Dial(context.Background(), "tcp", "localhost:8081")
// if err != nil {
// 	fmt.Println(err)
// }
// fmt.Println(socket.LocalAddr())
// client := &http.Client{}
// // Perform the request	// conn, err := net.Dial("tcp", "192.168.0.159:7351")
// if err != nil {
// 	fmt.Println(err)
// 	return
// }

// defer conn.Close()
// io.Copy(os.Stdout, conn)
// fmt.Println("\nDone")0", "text/plain", bytes.NewBufferString("Hello Go!"))
// if err != nil {
// 	log.Fatalf("Failed get: %s", err)
// }
// defer resp.Body.Close()
//==============================================
// c := evtwebsocket.Conn{
// 	OnConnected: func(w *websocket.Conn) {
// 		fmt.Println("Connected")
// 	},
// 	OnMessage: func(msg []byte) {
// 		fmt.Printf("Received message: %s\n", msg)
// 	},
// 	OnError: func(err error) {
// 		fmt.Printf("** ERROR **\n%s\n", err.Error())
// 	},
// }
// // Connect
// c.Dial("http://localhost:7350")
// c.Send([]byte("TEST"), nil)
//===================================================

// }

//========================================================================
// func main() {
// RemoveFolder("test5")
// fmt.Println(os.Getwd())

// for i := 0; i < 10; i++ {
// 	for k := 0; k < 9-i; k++ {
// 		fmt.Print("-")
// 	}
// 	for starts := 0; starts < 2*i+1; starts++ {
// 		fmt.Print("*")
// 	}
// 	fmt.Println("-")
// }

// CreateStorage().MoveFile("test4", ".storage/", "test3")
// RemoveFile("storage/test1", "file.txt")
// CreateFile(storage, "fl.txt")
// fmt.Println(listFolder(("./storage/")))

// err := filepath.Walk("/file.txt",
// 	func(path string, info os.FileInfo, err error) error {
// 		if err != nil {
// 			return err
// 		}
// 		fmt.Println(path)
// 		return err
// 	})
// if err != nil {
// 	log.Println(err)
// }

// f, err := os.Open("./storage")
// if err != nil {
// 	fmt.Println(err)
// 	return
// }
// files, err := f.Readdir(0)
// if err != nil {
// 	fmt.Println(err)
// 	return
// }

// for _, v := range files {
// 	fmt.Println(v.Name(), v.IsDir())
// }
// dir, err := os.Getwd()
// if err != nil {
// 	log.Fatal(err)
// }
// fmt.Println(dir)
// fmt.Println(FilePathWalkDir("./"))
// fmt.Println(OSReadDir("./storage/test1/file.txt"))

// }

func FilePathWalkDir(root string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func OSReadDir(root string) ([]string, error) {
	var files []string
	f, err := os.Open(root)
	if err != nil {
		return files, err
	}
	fileInfo, err := f.Readdir(-1)
	f.Close()
	if err != nil {
		return files, err
	}

	for _, file := range fileInfo {
		files = append(files, file.Name())
	}
	return files, nil
}

func listFolder(path string) (string, error) {
	var files string
	fileInfo, err := ioutil.ReadDir(path)
	if err != nil {
		log.Fatal(err)
	}

	for i := range fileInfo {
		files += fileInfo[i].Name() + " " + strconv.FormatBool(fileInfo[i].IsDir()) + "\n"
	}
	return files, err
}

func CreateFile(location string, fileName string) error {
	file, err := os.Create(location + "/" + fileName)
	if err != nil {
		log.Fatal(err)
	}
	file.Close()

	return nil
}

func (this *Storage) MoveFile(fileName string, oldPath string, newPath string) error {
	err := os.Rename(filepath.Join(oldPath, fileName), filepath.Join(newPath, fileName))
	if err != nil {
		log.Fatal(err)
	}
	return nil
}

// func twoSum(nums []int, target int) []int {
// 	mapNums := map[int]int{}
// 	for i := range nums {
// 		dif := target - nums[i]
// 		val, isExist := mapNums[dif]
// 		if isExist == true {
// 			return []int{val, i}
// 		} else {
// 			mapNums[nums[i]] = 1
// 		}
// 	}
// 	return nil
// }

// type ListNode struct {
// 	Val  int
// 	Next *ListNode
// }

// func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {

// }

//LEGASY CODE

// url := "https://www.google.com/"
// fmt.Printf("HTML code of %s ...\n", url)
// resp, err := http.Get(url)
// // handle the error if there is one
// if err != nil {
// 	panic(err)
// }
// // do this now so it won't be forgotten
// defer resp.Body.Close()
// // reads html as a slice of bytes
// html, err := ioutil.ReadAll(resp.Body)
// if err != nil {
// 	panic(err)
// }
// // show the HTML code as a string %s
// fmt.Printf("%s\n", html)
